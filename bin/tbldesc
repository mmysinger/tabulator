#!/usr/bin/env perl

use strict;
use warnings;
use Scalar::Util qw(looks_like_number);
use Getopt::Std;
use Pod::Usage;
use FileHandle;
use File::Basename;

my $infile = new FileHandle;

my $cnt_line = 0;    # number of lines processed
my $total_line =
  0;    # number of lines in file (can be different for sampling option)
my $skipped_target  = 0;   # lines skipped because target column was not numeric
my $skipped_samples = 0;   # lines skipped because of sampling option
my $skipped_columns = 0;   # lines skipped because of sampling option
my $col_target      = -1;  # target column to be predicted
my $name_target     = '';  # name of target columns
my $filename        = '';  # name of file
my %opt_na      = ( '' => 1 );    # missing values; always include empty field
my @opt_na_num  = ();             # numbers interpreted as missing values
my $delim       = "\t";           # column delimiter
my $max_strlen  = 0;
my $opt_gz      = 0;              # gzipped?
my $no_header   = 0;              # first line doesn't contain names
my $sample_line = 1.0;            # sample fraction
my %opt;                          # options

my @colnames;                     # column names from header
my @frac;                         # proportion of fractional numbers
my @sum;                          # sum of numeric values
my @sum_xx;                       # sum of squared numeric values
my @sum_xy;                       # sum of products between value and target
my @min_val;                      # minimum numeric value
my @max_val;                      # maximum numeric value
my @numeric;                      # proportion of numeric values
my @cnt_na;                       # number of undefined values

my @histogram;    # @column -> %value -> (count, sum target, sum^2 target)
my $histogram_limit =
  -1;    # maximum number of histogram values (limited for memory consumption)
my @histogram_truncated;    # was the maximum number reached?
my $num_report_values = 10; # number of values to report

my $KEY_NA =
  "?MISSING?";    # string to indicate NA, should not occur in input file itself
my $REPORT_NA = "";    # output string for non-applicable stats

my ( @summary, $col ); # output records and counter used in formatted output

#
# Command line options processing
#

sub parse_options
{
    my $opt_string = 'd:hk:l:mn:o:s:v:';
    Getopt::Std::getopts( $opt_string, \%opt ) or pod2usage(2);

    pod2usage( { -exitval => 0, -verbose => 2 } ) if $opt{'m'};
    pod2usage(1) if $opt{'h'};

    if ( defined $opt{'n'} )
    {
        foreach my $val ( split( ',', $opt{'n'} ) )
        {
            if ( looks_like_number($val) )
            {

                # use canonical form to compare numerical values
                push @opt_na_num, $val;
            }
            else
            {
                $opt_na{$val} = 1;
            }
        }
    }

    $delim             = $opt{'d'} if ( defined $opt{'d'} );
    $histogram_limit   = $opt{'l'} if ( defined $opt{'l'} );
    $num_report_values = $opt{'v'} if ( defined $opt{'v'} );
    $sample_line = min( max( 0.0, $opt{'s'} ), 1.0 ) if ( defined $opt{'s'} );

    foreach my $arg (@ARGV)
    {
        $filename = $arg unless ( $arg =~ m/^-/ );
    }

    if ( $filename eq '' )
    {
        if ( -t *STDIN )
        {

            # no arguments given
            pod2usage(
                {
                    -exitval => 2,
                    -verbose => 1,
                    -message => 'No argument given'
                }
            );
        }
        $filename = '-';
    }

    if ( $filename =~ /\.gz$|\.Z$|\.zip$/ )
    {

        # a GZIP file
        $opt_gz = 1;
    }
}

# copied from Statistics::Distributions to avoid necessity to install dependency

my $PI   = 3.14159265;
my $PiD2 = $PI / 2;

sub log10
{
    my $n = shift;
    return log($n) / log(10);
}

sub max
{
    my $max = shift;
    my $next;
    while (@_)
    {
        $next = shift;
        $max = $next if ( $next > $max );
    }
    return $max;
}

sub min
{
    my $min = shift;
    my $next;
    while (@_)
    {
        $next = shift;
        $min = $next if ( $next < $min );
    }
    return $min;
}

sub tprob
{    # Upper probability   t(x,n)
    my ( $n, $x ) = @_;
    if ( ( $n <= 0 ) || ( ( abs($n) - abs( int($n) ) ) != 0 ) )
    {
        die "Invalid n: $n\n";    # degree of freedom
    }
    return _subtprob( $n, $x );
}

sub fprob
{                                 # Upper probability   F(x,n1,n2)
    my ( $n, $m, $x ) = @_;
    if ( ( $n <= 0 ) || ( ( abs($n) - ( abs( int($n) ) ) ) != 0 ) )
    {
        die "Invalid n: $n\n";    # first degree of freedom
    }
    if ( ( $m <= 0 ) || ( ( abs($m) - ( abs( int($m) ) ) ) != 0 ) )
    {
        die "Invalid m: $m\n";    # second degree of freedom
    }
    return _subfprob( $n, $m, $x );
}

sub _subfprob
{
    my ( $n, $m, $x ) = @_;
    my $p;

    if ( $x <= 0 )
    {
        $p = 1;
    }
    elsif ( $m % 2 == 0 )
    {
        my $z = $m / ( $m + $n * $x );
        my $a = 1;
        for ( my $i = $m - 2 ; $i >= 2 ; $i -= 2 )
        {
            $a = 1 + ( $n + $i - 2 ) / $i * $z * $a;
        }
        $p = 1 - ( ( 1 - $z )**( $n / 2 ) * $a );
    }
    elsif ( $n % 2 == 0 )
    {
        my $z = $n * $x / ( $m + $n * $x );
        my $a = 1;
        for ( my $i = $n - 2 ; $i >= 2 ; $i -= 2 )
        {
            $a = 1 + ( $m + $i - 2 ) / $i * $z * $a;
        }
        $p = ( 1 - $z )**( $m / 2 ) * $a;
    }
    else
    {
        my $y = atan2( sqrt( $n * $x / $m ), 1 );
        my $z = sin($y)**2;
        my $a = ( $n == 1 ) ? 0 : 1;
        for ( my $i = $n - 2 ; $i >= 3 ; $i -= 2 )
        {
            $a = 1 + ( $m + $i - 2 ) / $i * $z * $a;
        }
        my $b = $PI;
        for ( my $i = 2 ; $i <= $m - 1 ; $i += 2 )
        {
            $b *= ( $i - 1 ) / $i;
        }
        my $p1 = 2 / $b * sin($y) * cos($y)**$m * $a;

        $z = cos($y)**2;
        $a = ( $m == 1 ) ? 0 : 1;
        for ( my $i = $m - 2 ; $i >= 3 ; $i -= 2 )
        {
            $a = 1 + ( $i - 1 ) / $i * $z * $a;
        }
        $p =
          max( 0, $p1 + 1 - 2 * $y / $PI - 2 / $PI * sin($y) * cos($y) * $a );
    }
    return $p;
}

sub _subtprob
{
    my ( $n, $x ) = @_;

    my ( $a, $b );
    my $w = atan2( $x / sqrt($n), 1 );
    my $z = cos($w)**2;
    my $y = 1;

    for ( my $i = $n - 2 ; $i >= 2 ; $i -= 2 )
    {
        $y = 1 + ( $i - 1 ) / $i * $z * $y;
    }

    if ( $n % 2 == 0 )
    {
        $a = sin($w) / 2;
        $b = .5;
    }
    else
    {
        $a = ( $n == 1 ) ? 0 : sin($w) * cos($w) / $PI;
        $b = .5 + $w / $PI;
    }
    return max( 0, 1 - $b - $a * $y );
}

sub _subf
{
    my ( $n, $m, $p ) = @_;
    my $x;

    if ( $p >= 1 || $p <= 0 )
    {
        die "Invalid p: $p\n";
    }

    if ( $p == 1 )
    {
        $x = 0;
    }
    elsif ( $m == 1 )
    {
        $x = 1 / ( _subt( $n, 0.5 - $p / 2 )**2 );
    }
    elsif ( $n == 1 )
    {
        $x = _subt( $m, $p / 2 )**2;
    }
    elsif ( $m == 2 )
    {
        my $u = _subchisqr( $m, 1 - $p );
        my $a = $m - 2;
        $x = 1 / (
            $u / $m * (
                1 + (
                    ( $u - $a ) / 2 + (
                        ( ( 4 * $u - 11 * $a ) * $u + $a * ( 7 * $m - 10 ) ) /
                          24 + (
                            (
                                ( 2 * $u - 10 * $a ) * $u +
                                  $a * ( 17 * $m - 26 )
                            ) * $u - $a * $a * ( 9 * $m - 6 )
                          ) / 48 /
                          $n
                      ) / $n
                  ) / $n
            )
        );
    }
    elsif ( $n > $m )
    {
        $x = 1 / _subf2( $m, $n, 1 - $p );
    }
    else
    {
        $x = _subf2( $n, $m, $p );
    }
    return $x;
}

sub _subf2
{
    my ( $n, $m, $p ) = @_;
    my $u  = _subchisqr( $n, $p );
    my $n2 = $n - 2;
    my $x  = $u / $n * (
        1 + (
            ( $u - $n2 ) / 2 + (
                ( ( 4 * $u - 11 * $n2 ) * $u + $n2 * ( 7 * $n - 10 ) ) / 24 + (
                    ( ( 2 * $u - 10 * $n2 ) * $u + $n2 * ( 17 * $n - 26 ) ) *
                      $u - $n2 *
                      $n2 *
                      ( 9 * $n - 6 )
                  ) / 48 / $m
              ) / $m
          ) / $m
    );
    my $delta;
    do
    {
        my $z = exp(
            (
                ( $n + $m ) * log( ( $n + $m ) / ( $n * $x + $m ) ) +
                  ( $n - 2 ) * log($x) +
                  log( $n * $m / ( $n + $m ) ) -
                  log( 4 * $PI ) -
                  ( 1 / $n + 1 / $m - 1 / ( $n + $m ) ) / 6
            ) / 2
        );
        $delta = ( _subfprob( $n, $m, $x ) - $p ) / $z;
        $x += $delta;
    } while ( abs($delta) > 3e-4 );
    return $x;
}

# use separate array for numerical values declared as missing
# to enable numerical comparison

sub looks_like_finite_number
{
    my $val = shift;
    return looks_like_number($val) && ( $val == $val );
}

sub is_na_number
{
    my $val = shift;
    foreach my $na_number (@opt_na_num)
    {
        if ( $val == $na_number )
        {
            return 1;
        }
    }
    return 0;
}

sub is_non_na_number
{
    my $val = shift;
    return looks_like_finite_number($val) && ( !is_na_number($val) );
}

sub is_na
{
    my $val = shift;
    if ( looks_like_number($val) )
    {

        # looks_like_number accepts nan,inf -> test if equal to self
        return ( $val != $val || ( $#opt_na_num >= 0 && is_na_number($val) ) );
    }
    return ( exists $opt_na{$val} );
}

# compute median from histogram
sub med
{
    my $histogram = shift;

    my @keys_sorted =
      sort { $a <=> $b } ( grep { is_non_na_number($_) } ( keys %$histogram ) );

    if ( $#keys_sorted <= -1 )
    {
        return $REPORT_NA;
    }

    # first iteration: count total
    my $cnt = 0;

    foreach my $key (@keys_sorted)
    {
        $cnt += $histogram->{$key}[0];
    }

    # second iteration: find median

    my $cnt_left = 0;
    my $half     = $cnt / 2;
    my $i        = 0;

    for ( $i = 0 ; $i <= $#keys_sorted ; $i++ )
    {
        $cnt_left += $histogram->{ $keys_sorted[$i] }[0];
        last if ( $cnt_left >= $half );
    }

    my $med = $keys_sorted[$i] + 0;

    if ( $i < $#keys_sorted && ( int($half) == $half ) && $cnt_left == $half )
    {

        # for even number of elements, pick average of the two middle ones
        $med = ( $keys_sorted[$i] + $keys_sorted[ $i + 1 ] ) / 2;
    }
    return $med;
}

sub adjust_fstat
{
    my ( $ss_e, $ss_r, $df ) = @_;
    if ( $df > 0 )
    {

   # f-statistic not stable for models with low error and many model parameters!
        if ( $ss_e <= 0 )
        {
            if ( $df >= 3 )
            {
                return 1e20;
            }
        }
        else
        {
            return $ss_r / ( $ss_e / $df );
        }
    }
    return 0.0;
}

# compute residula sum of squares from histogram
sub cond_var
{
    my $histogram = shift;

    my $cnt    = 0;
    my $ss_e   = 0.0;
    my $sum_y  = 0.0;
    my $sum_yy = 0.0;

    my @keys = grep { $_ ne $KEY_NA } ( keys %$histogram );

    foreach my $key (@keys)
    {
        if ( exists $histogram->{$key} )
        {
            my @stats =
              @{ $histogram->{$key} };    # count, sum(target), sum(target^2)
            $cnt    += $stats[0];
            $sum_y  += $stats[1];
            $sum_yy += $stats[2];

            # sum (y-mean(y))^2 = sum(y^2) - sum(y)^2/n
            $ss_e += $stats[2] - $stats[1] * $stats[1] / $stats[0];
        }
    }
    return ( $ss_e, $cnt, $sum_y, $sum_yy );
}

# guess file delimiter from header line
sub guess_delim
{
    my $line = shift;

    for my $delim ( "\t", ",", " ", "" )
    {
        return $delim if ( $line =~ m/$delim/ );
    }
    return "\t";
}

# read and store column names
sub process_header
{
    $infile->open( $opt_gz ? "gunzip -c $filename |" : $filename )
      or die "Couldn't open '$filename'";

    binmode( $infile, ":utf8" );

    ## Get field names from first line
    my $header = <$infile>;

    $header =~ s/\s+$//g;

    $delim = guess_delim($header) unless $opt{'d'};

    @colnames = map { s/^\s+//; s/\s$//; lc($_); } split( /$delim/, $header );

    # check if first line is indeed header

    my @alt_colnames;
    my $cnt = 0;
    foreach my $colname (@colnames)
    {
        $cnt++;
        if ( looks_like_number($colname) )
        {
            $no_header = 1;
        }
        push @alt_colnames, $cnt;
    }

    @colnames = @alt_colnames if ($no_header);    # use col idx instead of name

    $max_strlen = 0;
    foreach my $colname (@colnames)
    {
        my $len = length($colname);
        $max_strlen = $len if ( $len > $max_strlen );
    }

    $col_target  = -1;
    $name_target = "";

    if ( defined $opt{'k'} )
    {
        $name_target = $opt{'k'};
        $name_target = lc($name_target);
    }

    # initialize stats
    for ( my $col = 0 ; $col <= $#colnames ; $col++ )
    {
        $col_target = $col if ( $colnames[$col] eq $name_target );
        $sum[$col] = 0.0;
        $sum_xx[$col]              = 0.0;
        $sum_xy[$col]              = 0.0;
        $min_val[$col]             = 1e30;
        $max_val[$col]             = -1e30;
        $numeric[$col]             = 0;
        $cnt_na[$col]              = 0;
        $frac[$col]                = 0;
        $histogram[$col]           = { $KEY_NA => [ 0, 0, 0 ] };
        $histogram_truncated[$col] = 0;
    }

    if ( defined $opt{'k'} and $col_target == -1 )
    {
        die "Error: target column not found: $name_target";
    }
    return $max_strlen;
}

sub process_file
{
    $total_line = 0;
    $cnt_line   = 0;

    while (<$infile>)
    {
        $total_line++;

        if ( $sample_line < 1 && rand() > $sample_line )
        {
            $skipped_samples++;
            next;
        }

        # fill result from line
        chomp;

        my @vals = split( /$delim/, $_, -1 );

        if ( scalar(@vals) != scalar(@colnames) )
        {
            print STDERR "Warning: number of header fields ("
              . scalar(@colnames)
              . ") in line $cnt_line != number of data fields ("
              . scalar(@vals) . ")\n";
            print STDERR join( " / ", @vals ) . "\n";
            $skipped_columns++;

            next;
        }

        # if target column is not numeric, skip entire line

        my $target_field = 0;
        if ( $col_target != -1 )
        {
            my $field = $vals[$col_target];
            $field =~ s/[\"\'\s]+$//g;
            $field =~ s/^[\"\'\s]+//g;

            if ( !is_non_na_number($field) )
            {
                $skipped_target++;
                next;
            }
            $target_field = $field;
        }

        $cnt_line++;

        for ( my $col = 0 ; $col <= $#vals ; $col++ )
        {
            my $field = $vals[$col];

            $field =~ s/[\"\'\s]+$//g;
            $field =~ s/^[\"\'\s]+//g;

            my $is_na = 0;
            if ( looks_like_number($field) )
            {
                $is_na = ( $field != $field ) || is_na_number($field);

                if ($is_na)
                {
                    $cnt_na[$col]++;
                }
                else
                {
                    if ( $colnames[$col] eq 'keywords' )
                    {
                        printf( "ACCEPT\t%s\t%s\n", $field, ( $field + 0 ) );
                    }
                    $numeric[$col]++;
                    $min_val[$col] = $field if ( $min_val[$col] > $field );
                    $max_val[$col] = $field if ( $max_val[$col] < $field );

                    $sum[$col]    += $field;
                    $sum_xx[$col] += $field * $field;
                    $frac[$col]++ unless ( $field =~ /^[+-]?\d+\z/ );

                    if ( $col_target != -1 )
                    {
                        $sum_xy[$col] += $field * $target_field;
                    }
                }
            }
            else
            {
                $is_na = exists $opt_na{$field};

                if ($is_na)
                {
                    $cnt_na[$col]++;
                }
            }

# if target col defined, need to collect stats for na values in order to determine mse
            my $histogram_i = $histogram[$col];

            # map all (possibly different) missing indicators to one
            my $dict_key = ( $is_na ? $KEY_NA : $field );
            if ( exists $histogram_i->{$dict_key} )
            {
                $histogram_i->{$dict_key}[0]++;
                if ( $col_target != -1 )
                {
                    $histogram_i->{$dict_key}[1] += $target_field;
                    $histogram_i->{$dict_key}[2] +=
                      $target_field * $target_field;
                }
            }
            elsif ($histogram_limit < 0
                || ( scalar( keys %$histogram_i ) < $histogram_limit )
                || $is_na )    # na should always be included!
            {

                # initialize record
                $histogram_i->{$dict_key} = [
                    1,
                    1.0 * $target_field,
                    1.0 * $target_field * $target_field
                ];
            }
            else
            {

                # value truncated in histogram count
                $histogram_truncated[$col] = 1;
            }
        }
    }
    close($infile);
}

sub compute_summary
{
    my $cnt_y  = 0;
    my $ss_t   = 0.0;
    my $sum_y  = 0.0;
    my $sum_yy = 0.0;

# regression computation:
# ss_t = sum((y-mean(y)^2)        [total sum of squares]
# ss_r = sum((y_hat - mean(y))^2) [model sum of squares]
# ss_e = sum((y - y_hat)^2)       [error sum of squares, rss]
# ss_t = ss_e + ss_r
# adjusted r^2 value:
# r^2adj = 1 - ss_e*(n-1)/(sst/(n-p-1))
# adjusted f statistic: ss_r / (ss_e / (n-p))
# see e.g., http//www.weibull.com/DOEWeb/hypothesis_tests_in_simple_linear_regression.htm, http://en.wikipedia.org/wiki/Coefficient_of_determination

    if ( $col_target != -1 )
    {

        # linear correlation stats

        $cnt_y  = $numeric[$col_target];
        $sum_y  = $sum[$col_target];
        $sum_yy = $sum_xx[$col_target];
        $ss_t   = $sum_yy - $sum_y * $sum_y / $cnt_y;
    }

    for ( $col = 0 ; $col <= $#colnames ; $col++ )
    {

        # determine type
        my $type = 'flt';

        my $cnt_num = $numeric[$col];
        my $cnt_x   = $cnt_line - $cnt_na[$col];
        my $ss_x    = 0.0;

        if ( $cnt_num == 0 )
        {
            $type = 'char';
        }
        else
        {

            # at least one number detected
            $type = 'int' if ( $frac[$col] == 0 );
            $type = 'num' if ( $frac[$col] > 0 && $frac[$col] < $cnt_num );
            $type = $type . '/char' if ( $cnt_num < $cnt_x );
        }

        my $prop_char = ( $cnt_x - $cnt_num ) / $cnt_line;

        my $pval   = 1.0;
        my $mean_x = $REPORT_NA;

        $summary[$col] = {
            'col'    => ( $col + 1 ),
            'name'   => $colnames[$col],
            'type'   => $type,
            'na'     => $cnt_na[$col] / $cnt_line,
            'char'   => ( $cnt_x - $cnt_num ) / $cnt_line,
            'int'    => ( $cnt_num - $frac[$col] ) / $cnt_line,
            'mean'   => $REPORT_NA,
            'med'    => $REPORT_NA,
            'min'    => $REPORT_NA,
            'max'    => $REPORT_NA,
            'std'    => $REPORT_NA,
            'mar'    => 1.0,
            'r2adj'  => 0.0,
            'corr'   => $REPORT_NA,
            'pval'   => 1.0,
            'values' => ''
        };

        my $histogram_i = $histogram[$col];

        # number of distinct values
        my $cnt_uniq = scalar( grep { $_ ne $KEY_NA } keys %$histogram_i );

        if ( $cnt_num > 0 )
        {

            # numeric per-column stats
            $mean_x = $sum[$col] / $cnt_num;
            $ss_x   = $sum_xx[$col] - $sum[$col] * $sum[$col] / $cnt_num;

            $summary[$col]->{'mean'} = $sum[$col] / $cnt_num;
            $summary[$col]->{'med'}  = med($histogram_i);
            $summary[$col]->{'min'}  = $min_val[$col];
            $summary[$col]->{'max'}  = $max_val[$col];
            $summary[$col]->{'std'} =
              ( $cnt_num < 1 ) ? 0.0 : sqrt( abs($ss_x) / ( $cnt_num - 1 ) );

        }

        # values: exclude na, sort by frequency
        # if target column specified, also output prediction values
        my @val_enum;
        if ( $col_target != -1 )
        {

#@val_enum = map { sprintf( "'%s'x%d=>%.3g", $_, $histogram_i->{$_}[0], $histogram_i->{$_}[1]/ $histogram_i->{$_}[0] ) } sort { $histogram_i->{$b}[0] <=> $histogram_i->{$a}[0] } (grep { $_ ne $KEY_NA } keys %$histogram_i );
            @val_enum = map {
                sprintf( "'%s'x%d=>%.3g",
                    $_,
                    $histogram_i->{$_}[0],
                    $histogram_i->{$_}[1] / $histogram_i->{$_}[0] )
              } sort { $histogram_i->{$b}[0] <=> $histogram_i->{$a}[0] }
              ( grep { $histogram_i->{$_}[0] > 0 } keys %$histogram_i );
        }
        else
        {
            @val_enum =
              map { sprintf( "%sx%d", $_, $histogram_i->{$_}[0] ) }
              sort { $histogram_i->{$b}[0] <=> $histogram_i->{$a}[0] }
              ( grep { $_ ne $KEY_NA } keys %$histogram_i );
        }

        if ( $num_report_values > -1 )
        {
            @val_enum =
              @val_enum[ 0 .. min( $#val_enum, $num_report_values - 1 ) ];
        }
        if ( $#val_enum >= 0 )
        {
            $summary[$col]->{'values'} =
                ( $histogram_truncated[$col] ? '>= ' : '' )
              . "$cnt_uniq uniq: "
              . join( ', ', @val_enum );
        }

        if ( $col_target != -1 )
        {
            my ( $cnt_na, $sum_y_na, $sum_yy_na ) =
              @{ $histogram_i->{$KEY_NA} };

            my $sum_y_non_na  = $sum_y - $sum_y_na;
            my $sum_yy_non_na = $sum_yy - $sum_yy_na;
            my $ss_t_non_na =
              $sum_yy_non_na - $sum_y_non_na * $sum_y_non_na / $cnt_x;

            # degree of freedoms both for linear regression and na/non_na split
            my $df = $cnt_x - 2;

            my $f_adj = 0.0;

            if ( $cnt_na > 0 )
            {

           # compute f statistic for model that splits y values into two classes
           # based on whether x is missing (2 parameters)

                my $ss_t_na    = $sum_yy_na - $sum_y_na * $sum_y_na / $cnt_na;
                my $ss_e_split = $ss_t_na + $ss_t_non_na;
                my $ss_r_split = $ss_t - $ss_e_split;

                my $f_adj_split = adjust_fstat( $ss_e_split, $ss_r_split, $df );

                $summary[$col]->{'mar'} =
                  max( 0.0, fprob( 1, $df, $f_adj_split ) );

#printf("MAR %s %d %f %f %f %f %f %f\n", $colnames[$col], $cnt_na, $f_adj_split, $ss_e_split, $ss_r_split, $ss_t_non_na, $ss_t_na, $ss_t);
            }

            # determine type of predictor

            my $is_continuous = ( $prop_char == 0 ) && ( $cnt_uniq >= 3 );

            my $r2_adj = 0.0;

            if ($is_continuous)
            {

                # s_xy = sum((x-mean(x)(y-mean(y))
                my $s_xy = $sum_xy[$col] - $sum[$col] * $sum_y_non_na / $cnt_x;

                my $denom = $ss_x * $ss_t_non_na;
                my $corr = $denom <= 0 ? 0 : $s_xy / sqrt($denom);

                $summary[$col]->{'corr'} = $corr;

                # compute parameters, y = a + b * x
                my $mean_y_non_na = $sum_y_non_na / $cnt_x;
                my $b             = $corr * sqrt( $ss_t_non_na / $ss_x );
                my $a             = $mean_y_non_na - $b * $mean_x;

                # sum(y^*y^) = sum((a+by)^2) = n*a^2+ 2ab sum(x) + b^2*sum(x^2)
                my $sum_yhat_yhat =
                  $cnt_x * $a * $a +
                  2 * $a * $b * $sum[$col] +
                  $b * $b * $sum_xx[$col];

                # sum(y^) = n*a+b*sum(x)
                my $sum_yhat = $cnt_x * $a + $b * $sum[$col];

     # ssr = sum((y^-mean(y))^2) = sum(y^*y^) - 2mean(y)*sum(y^) + n*(mean(y))^2
                my $ss_r =
                  $sum_yhat_yhat -
                  2 * $mean_y_non_na * $sum_yhat +
                  $cnt_x * $mean_y_non_na * $mean_y_non_na;
                my $ss_e = $ss_t_non_na - $ss_r;

                my $r2 = $corr * $corr;
                $r2_adj = 1 - ( 1 - $r2 ) * ( $cnt_x - 1 ) / $df;

                $summary[$col]->{'r2adj'} = $r2_adj;

                $f_adj = adjust_fstat( $ss_e, $ss_r, $df );

                $pval = max( 0.0, fprob( 1, $df, $f_adj ) );

                $summary[$col]->{'pval'} = $pval;

                # format correlation coefficient for output
                $summary[$col]->{'corr'} = sprintf( "%.1f", 100 * $corr );

            }

            if ( !$is_continuous || ( !$histogram_truncated[$col] ) )
            {

                # interpret as categorical predictor
                my ( $ss_e_non_na, $cnt ) = cond_var($histogram_i);

                my $ss_r = $ss_t_non_na - $ss_e_non_na;
                $df = $cnt_x - $cnt_uniq;
                $f_adj = adjust_fstat( $ss_e_non_na, $ss_r, $df );
                my $r2_adj_categorical = (
                    $df < 3 ? 0.0
                    : (
                        $ss_t_non_na <= 0 ? 1e20
                        : ( 1.0 -
                              $ss_e_non_na *
                              ( $cnt_x - 1 ) /
                              ( $ss_t_non_na * $df ) )
                    )
                );
                my $pval_categorical =
                  ( $df < 3 ? 1.0 : max( 0.0, fprob( 1, $df, $f_adj ) ) );

                if ( ( $pval_categorical < 0.1 || $pval_categorical < $pval )
                    && $r2_adj_categorical > $r2_adj )
                {

         # categorical prediction seems to be better than linear, use for output
                    $summary[$col]->{'r2adj'} = $r2_adj_categorical;
                    $summary[$col]->{'pval'}  = $pval_categorical;
                    $summary[$col]->{'corr'}  = $REPORT_NA;
                }
            }

        }
    }
}

# output format with target column

format FORMAT_LONG_TOP = 
=======================================================================================================================================
@<< @<<<<<<<<<<<<<< | @<<<<<<< @>>>> @>>>> @>>>> @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> | @>>>> @>>>> @>>>>> @>>>>  @<<<<<<<<<<<<
"COL", "NAME", "TYPE", "NA", "CHAR", "INT", "MEAN", "MED", "MIN", "MAX", "STD", "MAR", "R2ADJ", "CORR", "PVAL", "VALUES"
=======================================================================================================================================
.

format FORMAT_LONG = 
@<< ^<<<<<<<<<<<<<< | @<<<<<<< @##.# @##.# @##.# @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> | @##.# @##.# @>>>>> @##.#  ^<<<<<<<<<<<<
 $summary[$col]->{'col'}, $summary[$col]->{'name'}, $summary[$col]->{'type'}, 100.0 * $summary[$col]->{'na'}, 100.0 * $summary[$col]->{'char'}, 100.0 * $summary[$col]->{'int'}, &format_field($summary[$col]->{'mean'},8,3), &format_field($summary[$col]->{'med'},8,3), &format_field($summary[$col]->{'min'},8,3),format_field($summary[$col]->{'max'},8,3), &format_field($summary[$col]->{'std'},8,3), 100.0 * $summary[$col]->{'mar'}, 100.0 * $summary[$col]->{'r2adj'}, $summary[$col]->{'corr'}, 100.0 * $summary[$col]->{'pval'}, $summary[$col]->{'values'}
    ^<<<<<<<<<<<<<< |                                                                         |                           ^<<<<<<<<<<<< ~~
$summary[$col]->{'name'}, $summary[$col]->{'values'}
_______________________________________________________________________________________________________________________________________
.

# output format without target column

format FORMAT_SHORT_TOP = 
============================================================================================================
@<< @<<<<<<<<<<<<<< | @<<<<<<< @>>>> @>>>> @>>>> @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>>  @<<<<<<<<<<<<
"COL", "NAME", "TYPE", "NA", "CHAR", "INT", "MEAN", "MED", "MIN", "MAX", "STD", "VALUES"
============================================================================================================
.

format FORMAT_SHORT = 
@<< ^<<<<<<<<<<<<<< | @<<<<<<< @##.# @##.# @##.# @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> @>>>>>>> ^<<<<<<<<<<<<
 $summary[$col]->{'col'}, $summary[$col]->{'name'}, $summary[$col]->{'type'}, 100.0 * $summary[$col]->{'na'}, 100.0 * $summary[$col]->{'char'}, 100.0 * $summary[$col]->{'int'}, &format_field($summary[$col]->{'mean'},8,3), &format_field($summary[$col]->{'med'},8,3), &format_field($summary[$col]->{'min'},8,3),format_field($summary[$col]->{'max'},8,3), &format_field($summary[$col]->{'std'},8,3), $summary[$col]->{'values'}
    ^<<<<<<<<<<<<<< |                                                                         ^<<<<<<<<<<<< ~~
$summary[$col]->{'name'}, $summary[$col]->{'values'}
___________________________________________________________________________________________________________
.

sub format_field
{
    my ( $val, $width, $prec ) = @_;

    my $s = '';
    if ( looks_like_number($val) )
    {
        if ( $val =~ /^[+-]?\d+\z/ )
        {
            $s = sprintf( "%${width}d", $val );
        }
        else
        {
            my $fmt = "%$width";
            $fmt .= ".$prec" if $prec;
            $fmt .= "g";

            $s = sprintf( $fmt, $val );
        }
    }
    else
    {
        $s = sprintf( "%${width}s", $val );
    }
    return $s;
}

# comparison: numbers before strings, each sorted accordingly
sub smart_cmp
{
    my ( $a, $b ) = @_;
    if ( looks_like_number($a) )
    {
        if ( looks_like_number($b) )
        {
            return $a <=> $b;
        }
        else
        {
            return -1;
        }
    }
    else
    {
        if ( looks_like_number($b) )
        {
            return 1;
        }
        else
        {
            return $a cmp $b;
        }
    }
}

sub print_report
{
    print "Summarizing: $filename\n";
    print "No header line found" if ($no_header);

    print "Lines in file: $total_line\n";
    print "Processed lines: $cnt_line\n" if ( $cnt_line < $total_line );

    if ( $skipped_columns > 0 )
    {
        print
"Skipped lines because of wrong number of columns: $skipped_columns\n";
    }

    if ( $skipped_target > 0 )
    {
        print
          "Skipped lines because of missing target value: $skipped_target\n";
    }

    if ( $skipped_samples > 0 )
    {
        print "Skipped lines because of sampling: $skipped_samples\n";
    }

    # default output order: same as columns in file
    my @order = 0 .. $#colnames;

    my $order_name = "file order";

    if ( $col_target != -1 )
    {
        print "Target column: $name_target\n";
        if ($skipped_target)
        {
            print "Skipped lines because target missing: $skipped_target\n";
        }

        # if target column given, order by adjusted r^2 statistic
        $order_name = "adjusted R^2 statistic";

        @order =
          sort { smart_cmp( $summary[$b]->{'r2adj'}, $summary[$a]->{'r2adj'} ) }
          0 .. $#colnames;
    }

    if ( $opt{'o'} )
    {
        my $order_col = $opt{'o'};

        # ordering option given
        if ( exists $summary[0]->{$order_col} )
        {
            if ( $order_col eq 'pval' || $order_col eq 'mar' )
            {

                # lowest values first
                @order = sort {
                    smart_cmp(
                        $summary[$a]->{$order_col},
                        $summary[$b]->{$order_col}
                      )
                } 0 .. $#colnames;
            }
            else
            {

                # highest values first
                @order = sort {
                    smart_cmp(
                        $summary[$b]->{$order_col},
                        $summary[$a]->{$order_col}
                      )
                } 0 .. $#colnames;
            }
            $order_name = $order_col;
        }
        else
        {
            print STDERR
"Warning: invalid ordering '$order_col' specified, use any available: "
              . join( ',', keys %{ $summary[0] } ) . "\n";
        }
    }

    print "Columns ordered by: $order_name\n";

    print "The following strings are interpreted as missing values: "
      . join( ',', map { "\"$_\"" } ( keys %opt_na ) ) . "\n";
    my @truncated_cols;
    for ( my $col = 0 ; $col <= $#colnames ; $col++ )
    {
        if ( $histogram_truncated[$col] )
        {
            push @truncated_cols, $colnames[$col];
        }
    }

    if ( $#truncated_cols >= 0 )
    {
        print
"The following columns have more than $histogram_limit unique values; median and categorical prediction might not be accurate, use option -l to correct: "
          . join( ',', @truncated_cols ) . "\n";
    }

    print("\n\n");

    if ( $col_target != -1 )
    {
        $~ = "FORMAT_LONG";
        $^ = "FORMAT_LONG_TOP";
    }
    else
    {
        $~ = "FORMAT_SHORT";
        $^ = "FORMAT_SHORT_TOP";
    }

    $^L = "";    # FORMFEED CHARACTER

    for ( my $i = 0 ; $i <= $#colnames ; $i++ )
    {
        $col = $order[$i];
        write;
    }
}

sub main
{

    binmode STDIN,  ":utf8";
    binmode STDOUT, ":utf8";

    # parse options
    parse_options();

    binmode STDOUT, ':utf8';

    # gather columns names
    process_header();

    # process lines in input file
    process_file();

    # compute summary statistics
    compute_summary();

    # output
    print_report();
}

main;

__END__

=head1 NAME

tbldesc - Describe columns in tabular file

=head1 SYNOPSIS

B<tbldesc>      S<[ B<-dhklmnosv> ] file>

=head1 OPTIONS

=over

=item B<-d> 

Column delimiter [Default: try any of '\t', ' ', ',']

=item B<-h>

Show this help message.

=item B<-k>

Specify target column. This results in the computation of correlation statistics with each other column, see below.

=item B<-l>

Limit number of discrete values to record. The purpose of this option is to reduce the required memory, in exchange for accuracy. Note that for accurate computation of medians as well as categorical predictors, all values have to be recorded.

=item B<-m>

Print manual page

=item B<-n>

Comma-delimited list of values meaning 'not available' (missing)

=item B<-o>

Determine the order in which columns are reported. Valid arguments are any of the existing output fields: I<col, name, type, na, char, int, mean, med, min, max, std, mar, r2adj, corr, pval, values>.


=item B<-s>

Sample fraction [0..1]. The purpose of this option is to increase the speed of the program, in exchange for accuracy. Lines in the file will be uniformly sampled.

=item B<-v>

Maximum number of individual values to be listed under columns B<values> [Default: 10].

=back

=head1 DESCRIPTION

tbldesc quickly scans large files with tabular data, and provides an overview of the contents of the columns. In case that you are interested in predicting one of the columns, it screens for candidate columns with high correlation (see option B<-k>). It is assumed that the first line of the file specifies the column names. The program always prints out the following statistics:

=over

=item B<col>

Column number in file

=item B<name>

Column name

=item B<type>

I<float, int, char>, or combinations of these, as occurring in the column

=item B<na>

Percentage of missing values [0-100]. Empty, NAN, and INF entries are interpreted as missing, in addition to user-specified values (see option B<-n>)

=item B<char>

Percentage of non-numeric values [0-100]

=item B<int>

Percentage of integer values [0-100]

=item B<mean>

Mean value

=item B<med>

Median value

=item B<min>

Minimum

=item B<max>

Maximum

=item B<std>

Standard deviation

=item B<values>

A sample of the most frequent values, with occurrence counts.

=back

A target column ('dependent variable') can be specified with the 'B<-k>' option. This column is expected to have only numerical values; binary classification can be approximated by encoding the target using two values, e.g., 0 and 1. If the target value is undefined, the entire line is ignored. With the 'B<-k>' option, a number of additional values are displayed. Three simple prediction models are computed, for each other column ('independent variable') in the file, to minimize the mean square error. The first one just predicts two possible values, based on whether the input column is missing. Column B<mar> shows the significance of this model [0-100], lower values indicating more evidence that the missing pattern is I<not> independent of the target value. Secondly, a simple linear regression is performed. The third, I<categorical> predictor can output one value for each independent value. The second and third predictors are only applied to non-missing data. The I<adjusted R^2> statistic measures the proportion of variance explained, given the degrees of freedom of the model. The maximum value is 100.0, for a perfect predictor. For some background, see e.g. L<http://www.weibull.com/DOEWeb/hypothesis_tests_in_simple_linear_regression.htm> or L<http://en.wikipedia.org/wiki/Coefficient_of_determination>.

=over

=item B<mar>

I<Missing at random> significance [0-100], lower values mean less random.

=item B<r2adj>

Adjusted R^2 statistic [-100], higher values mean better prediction.

=item B<corr>

Pearson correlation coefficient [-100:100], for linear regression. Not shown for categorical variables, or if categorical predictor has better adjusted R^2 statistic.

=item B<pval>

F-test p-value [0-100] for statistical significance of the linear regression or categorical predictor, whichever is better. Lower values mean higher significance.

=back

=head1 EXAMPLE

Suppose F<file> contains the following lines:

  name,sex,house_nr,height,shoe_size
  arthur,m,42,181,11.5
  berta,f,101,163,8.5
  chris,m,1333,175,10
  don,m,77,185,12.5
  elisa,f,204,166,7

Then B<tbldesc -k shoe_size file> prints:


        COL NAME            | TYPE        NA  CHAR   INT     MEAN      MED      MIN      MAX      STD |   MAR R2ADJ   CORR  PVAL  VALUES
        =======================================================================================================================================
        5   shoe_size       | num        0.0   0.0  40.0      9.9       10        7     12.5     2.22 | 100.0 100.0  100.0   0.0  5 uniq:
                            |                                                                         |                           '8.5'x1=>8.5,
                            |                                                                         |                           '7'x1=>7,
                            |                                                                         |                           '12.5'x1=>12.
                            |                                                                         |                           5,
                            |                                                                         |                           '10'x1=>10,
                            |                                                                         |                           '11.5'x1=>11.
                            |                                                                         |                           5
        _______________________________________________________________________________________________________________________________________
        4   height          | int        0.0   0.0 100.0      174      175      163      185     9.43 | 100.0  83.8   93.7   1.9  5 uniq:
                            |                                                                         |                           '163'x1=>8.5,
                            |                                                                         |                           '166'x1=>7,
                            |                                                                         |                           '181'x1=>11.5
                            |                                                                         |                           ,
                            |                                                                         |                           '185'x1=>12.5
                            |                                                                         |                           , '175'x1=>10
        _______________________________________________________________________________________________________________________________________
        2   sex             | char       0.0 100.0   0.0                                              | 100.0  71.0          4.6  2 uniq:
                            |                                                                         |                           'm'x3=>11.3,
                            |                                                                         |                           'f'x2=>7.75
        _______________________________________________________________________________________________________________________________________
        1   name            | char       0.0 100.0   0.0                                              | 100.0   0.0        100.0  5 uniq:
                            |                                                                         |                           'don'x1=>12.5
                            |                                                                         |                           ,
                            |                                                                         |                           'elisa'x1=>7,
                            |                                                                         |                           'berta'x1=>8.
                            |                                                                         |                           5,
                            |                                                                         |                           'arthur'x1=>1
                            |                                                                         |                           1.5,
                            |                                                                         |                           'chris'x1=>10
        _______________________________________________________________________________________________________________________________________
        3   house_nr        | int        0.0   0.0 100.0      351      101       42     1333      552 | 100.0 -32.7   -6.8  91.4  5 uniq:
                            |                                                                         |                           '42'x1=>11.5,
                            |                                                                         |                           '204'x1=>7,
                            |                                                                         |                           '77'x1=>12.5,
                            |                                                                         |                           '101'x1=>8.5,
                            |                                                                         |                           '1333'x1=>10
        _______________________________________________________________________________________________________________________________________

Note that the results are ordered by adjusted R^2. I<shoe_size> trivially has a correlation of 100% with itself; the correlation between I<height> and I<shoe_size> is highly significant, as is the categorical dependency on I<sex>. The p-values for name and house number are high, indicating no correlation. 
